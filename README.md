# Bloc
Bloc 是一个致力于将程序员从需求变化中解放出来的工作流管理平台

***目前第一个版本还未上线***

**目录**
- [核心思想](#核心思想)
- [适用场景](#适用场景)
- [一个例子说明项目的优势](#一个例子说明项目优势)
- [开发规划](#开发规划)
<!-- - [使用流程概述](#使用流程概述) -->

## 核心思想
在开发的过程中，我发现程序员的精力会被非常非常多的非开发需求所占据:
![before_bloc](/static/before_bloc.png)

如上图，从最开始的一个单项需求的简单脚本，演进到后面的，事无巨细的需求变化和沟通成本，都需要通过程序员，导致耗费程序员的大量精力。

而使用了bloc后，我们希望的就是能够最大程度的**解耦需求变化**和**降低沟通成本**。需求变化和信息最大程度在bloc前端进行修改和获取：
![after_bloc](/static/after_bloc.png)

## 一个例子说明项目优势
假设为一个学校开发系统。假设年纪主任要找全年级平均成绩最高的几个学生来开家长会，那么会有以下的工作流：
![flow example](/static/flow_example.png)

`学生直接输入节点` - 此节点过滤学生输入源（如下面只要六年级的学生）：
![flow example](/static/user_ipt.png)

`计算成绩` - 根据输入的学生，以及配置的计算方式和挑选规则选出特定的学生：
![flow example](/static/score_calcu.png)

`电话通知` - 对特定学生，电话通知输入的特定内容：
![phone call](/static/phone_call.png)

通过这个例子我们来看看基于bloc构建，带来了哪些优势：
// todo

## 适用场景
当前版本，由于还不支持function直接运行/长时间运行，故适用场景是事件驱动型/数据处理型任务。

<!-- 
## 使用流程概述
1. 用户基于对应编程语言(目前只有go)的SDK开发函数，形成一个`函数块`。SDK会要求函数实现以下的几个方法：
	1. 函数本身描述：说明函数本身的作用
	2. 输入描述：尽可能的将变化和控制**都**通过"参数"暴露出来作为控制函数运行的`富输入参数`
	3. 输出描述：将每个输出都进行说明
	4. Run方法：用于实际执行时被调用
2. 使用者直接在前端通过DAG拖拽`函数块`的方式构建`工作流`。特别注意的一点就是，这里不止是拖拽函数块就完了，而是还支持用户配置`函数块`的入参，而且入参不仅支持手动输入特定值、还支持将上游`函数块`的某个特定输出直接作为此函数的某参数的输入值！（这就是）
3. 构建好的`工作流`支持三种运行模式：
	1. 直接为此工作流配置`crontab表达式`以周期运行
	2. 直接为此工作流配置`触发key`，可通过调用http api并提供此key来触发此flow的运行
	3. 以`工作流`作为块，以DAG的方式构建`运行编排`。从而实现处理类似此工作流需要某工作流先完成的需求 -->

## 开发规划
// todo
