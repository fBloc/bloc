# Bloc
Bloc 是一个致力于将程序员从需求变化中解放出来的工作流管理平台

项目的最大目标是最大化的让需求变化不需要再经过程序员！让运营人员直接在前端进程操作就能满足需求的变化！

这个目标是通过将影响后端执行的一切参数暴露出来、一切前端可操作实现的。

***目前还未上线***

**目录**
- [项目说明](#项目说明)
	- 核心思想
	- 特征
	- 组件构成
	- 示意图
- [一个例子](#一个例子)
- [一些feature说明](#一些feature说明)
- [适用场景](#适用场景)
- [开发规划](#开发规划)
<!-- - [使用流程概述](#使用流程概述) -->

## 项目说明
### 核心思想
我们认为，一个执行是由多个函数块串联起来的，而其中各个函数的行为，可以通过函数的参数来决定。

从而出现的情况是：不同的函数块串联顺序以及不同的输入参数，就会形成一个新的执行（也就是能够满足新的需求）。

所以，bloc想要做到的事就是：开发者**只需**开发好各个函数、并且尽量将影响函数运行的参数（在项目中扩展为了"富参数"、支持更为广泛）暴露出来。
**剩下的就都不用管了** - 使用者自己通过bloc-前端界面来操控函数块的串联方式、其中各个函数块的参数输入、执行编排来满足使用者的新需求

### 特征
项目有以下特征：
1. 支持多语言的函数（目前是go、python）
2. 支持水平扩展运行函数块（部署的实例越多并行度就越大）
3. 支持跨代码仓库的函数提供（跨语言、跨仓库提供的函数都可以一起在前端被编排【同一个执行编排中的函数可以是来自不同仓库、不同语言提供的函数！】）
4. 执行时机编排同时支持周期（crontab）、Webhook触发、以及先后依赖顺序指定的方式

### 组件构成
组件构成图如下：

其中蓝色部分对应[bloc代码仓库](https://github.com/fbloc)提供的一些组件。
![component](/static/bloc_component.svg)

### 示意图
在使用bloc前的开发流程:

可能从最开始为单个需求开发的简单脚本，演进到后面的庞杂交织的应用。导致事无巨细的需求变化和沟通成本，都需要通过程序员，导致耗费程序员的大量精力。
![before_bloc](/static/before_bloc.png)

而使用了bloc后，我们希望的就是能够最大程度的**解耦需求变化**和**降低沟通成本**。
需求变化和信息最大程度的能在bloc前端进行获取和修改：
![after_bloc](/static/after_bloc.png)

## 一个例子
假设是一个学校

假设年纪主任要找全年级平均成绩最高的几个学生来开家长会，那么会有以下的工作流：
![flow example](/static/flow_example.png)

`学生直接输入节点` - 此节点过滤学生输入源（如下面只要六年级的学生）：
![flow example](/static/user_ipt.png)

`计算成绩` - 根据输入的学生，以及配置的计算方式和挑选规则选出特定的学生：
![flow example](/static/score_calcu.png)

`电话通知` - 对特定学生，电话通知输入的特定内容：
![phone call](/static/phone_call.png)

通过这个例子我们来看看基于bloc构建，带来了哪些优势：
1. 参数变化，举例：
	1. 如果第二天年纪主任改需求了，突然想找数学成绩最差的同学来开会 - 只需要将`计算成绩`节点中的学科选项选成数学再触发一次即可（开发者不需要参与）
2. 功能组合变化，举例：
	1. 如果第二班的老师看到了这个工作流，想看看看自己班的情况 - 只需要将此工作流fork一份到自己，然后将`学生直接输入节点`里面的班级过滤添加个二班再跑一次即可（开发者不需要参与）
2. 透明性问题，举例：
	1. 假如第二班的班主任突然发现年纪主任找自己的学生谈话了，那么如果其想要查看年级主任是依据什么来找家长的，其就可以直接在前端看出来，`计算成绩`节点里面配置了是根据「没有过滤学科」+「平均值」的计算方式过滤的，这样二班班主任直接就知道了年级主任是依据各科的平均分来找的（开发者不需要参与 & 也不需要找年级主任确定）
	2. 同理，第二班的班主任也直接能够通过这个的运行输出直接看出来找了哪些同学（从而看哪些是自己班的 - 甚至还可以fork这个工作流过来，再在最后的函数块后面加一个过滤节点来筛出来自己班的）
3. 扩展性：
	1. 假设现在突然教育部要求，每个孩子每晚要测体温进行上报，超过xx度的第二条不能上学，那么只需要添加一个体温输入的节点，并且为之设置好规则:
	![high_temp_flow](/static/high_temp_flow.png)
	直接在前端设置了>37.5度的学生需要上报
	![high_temp_func](/static/high_temp_func.png)
	直接在前端配置运行时间
	![temp_crontab](/static/temp_crontab.png)
	这里就是对应了"运行变化"，对于想要停掉或者修改或者了解运行时机的人，直接在前端就可以操作了
	
	2. 又假设学校突然变人性化，希望在天气变化比较大的时候提醒学生注意保暖
	可以构建如下的工作流
	![extrem weather flow](/static/extrem_weather_flow.png)
	特别说明：图中的第一层的三个节点是会并行运行的

4. 进阶版运行控制
//todo 说明基于arrangement的工作流上下游编排

## 一些feature说明
// todo

## 适用场景
当前版本，由于还不支持function直接运行/长时间运行，故适用场景是事件驱动型/数据处理型任务。

<!-- 
## 使用流程概述
1. 用户基于对应编程语言(目前只有go)的SDK开发函数，形成一个`函数块`。SDK会要求函数实现以下的几个方法：
	1. 函数本身描述：说明函数本身的作用
	2. 输入描述：尽可能的将变化和控制**都**通过"参数"暴露出来作为控制函数运行的`富输入参数`
	3. 输出描述：将每个输出都进行说明
	4. Run方法：用于实际执行时被调用
2. 使用者直接在前端通过DAG拖拽`函数块`的方式构建`工作流`。特别注意的一点就是，这里不止是拖拽函数块就完了，而是还支持用户配置`函数块`的入参，而且入参不仅支持手动输入特定值、还支持将上游`函数块`的某个特定输出直接作为此函数的某参数的输入值！（这就是）
3. 构建好的`工作流`支持三种运行模式：
	1. 直接为此工作流配置`crontab表达式`以周期运行
	2. 直接为此工作流配置`触发key`，可通过调用http api并提供此key来触发此flow的运行
	3. 以`工作流`作为块，以DAG的方式构建`运行编排`。从而实现处理类似此工作流需要某工作流先完成的需求 -->

## 开发规划
// todo

## 开发者文档
- [本地开发/测试环境搭建指南](/docs/devel/zh-CN/local-dev-enviroment.md)
- #todo 期望开发的功能
- #todo 生产环境搭建建议